// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// VariantSchemaPayloadType - The type of the value. Commonly used types are string, json and csv.
type VariantSchemaPayloadType string

const (
	VariantSchemaPayloadTypeJSON   VariantSchemaPayloadType = "json"
	VariantSchemaPayloadTypeCsv    VariantSchemaPayloadType = "csv"
	VariantSchemaPayloadTypeString VariantSchemaPayloadType = "string"
)

func (e VariantSchemaPayloadType) ToPointer() *VariantSchemaPayloadType {
	return &e
}

func (e *VariantSchemaPayloadType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "csv":
		fallthrough
	case "string":
		*e = VariantSchemaPayloadType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for VariantSchemaPayloadType: %v", v)
	}
}

// VariantSchemaPayload - Extra data configured for this variant
type VariantSchemaPayload struct {
	// The type of the value. Commonly used types are string, json and csv.
	Type VariantSchemaPayloadType `json:"type"`
	// The actual value of payload
	Value string `json:"value"`

	AdditionalProperties interface{} `json:"-"`
}
type _VariantSchemaPayload VariantSchemaPayload

func (c *VariantSchemaPayload) UnmarshalJSON(bs []byte) error {
	data := _VariantSchemaPayload{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = VariantSchemaPayload(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "type")
	delete(additionalFields, "value")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c VariantSchemaPayload) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_VariantSchemaPayload(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}

// VariantSchemaWeightType - Set to fix if this variant must have exactly the weight allocated to it. If the type is variable, the weight will adjust so that the total weight of all variants adds up to 1000
type VariantSchemaWeightType string

const (
	VariantSchemaWeightTypeVariable VariantSchemaWeightType = "variable"
	VariantSchemaWeightTypeFix      VariantSchemaWeightType = "fix"
)

func (e VariantSchemaWeightType) ToPointer() *VariantSchemaWeightType {
	return &e
}

func (e *VariantSchemaWeightType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variable":
		fallthrough
	case "fix":
		*e = VariantSchemaWeightType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for VariantSchemaWeightType: %v", v)
	}
}

// VariantSchema - A variant allows for further separation of users into segments. See [our excellent documentation](https://docs.getunleash.io/reference/feature-toggle-variants#what-are-variants) for a more detailed description
type VariantSchema struct {
	// The variants name. Is unique for this feature toggle
	Name string `json:"name"`
	// Overrides assigning specific variants to specific users. The weighting system automatically assigns users to specific groups for you, but any overrides in this list will take precedence.
	Overrides []OverrideSchema `json:"overrides,omitempty"`
	// Extra data configured for this variant
	Payload *VariantSchemaPayload `json:"payload,omitempty"`
	// [Stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) is how Unleash guarantees that the same user gets the same variant every time
	Stickiness *string `json:"stickiness,omitempty"`
	// The weight is the likelihood of any one user getting this variant. It is a number between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information
	Weight float64 `json:"weight"`
	// Set to fix if this variant must have exactly the weight allocated to it. If the type is variable, the weight will adjust so that the total weight of all variants adds up to 1000
	WeightType *VariantSchemaWeightType `json:"weightType,omitempty"`

	AdditionalProperties interface{} `json:"-"`
}
type _VariantSchema VariantSchema

func (c *VariantSchema) UnmarshalJSON(bs []byte) error {
	data := _VariantSchema{}

	if err := json.Unmarshal(bs, &data); err != nil {
		return err
	}
	*c = VariantSchema(data)

	additionalFields := make(map[string]interface{})

	if err := json.Unmarshal(bs, &additionalFields); err != nil {
		return err
	}
	delete(additionalFields, "name")
	delete(additionalFields, "overrides")
	delete(additionalFields, "payload")
	delete(additionalFields, "stickiness")
	delete(additionalFields, "weight")
	delete(additionalFields, "weightType")

	c.AdditionalProperties = additionalFields

	return nil
}

func (c VariantSchema) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	bs, err := json.Marshal(_VariantSchema(c))
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	bs, err = json.Marshal(c.AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal([]byte(bs), &out); err != nil {
		return nil, err
	}

	return json.Marshal(out)
}
