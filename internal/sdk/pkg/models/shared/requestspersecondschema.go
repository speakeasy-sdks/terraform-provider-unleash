// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy/terraform-provider-terraform/internal/sdk/pkg/utils"
)

// Metric - A key value set representing the metric
type Metric struct {
	// Name of the application this metric relates to
	AppName *string `json:"appName,omitempty"`
	// Which endpoint has been accessed
	Endpoint *string `json:"endpoint,omitempty"`
}

func (o *Metric) GetAppName() *string {
	if o == nil {
		return nil
	}
	return o.AppName
}

func (o *Metric) GetEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.Endpoint
}

type ValuesType string

const (
	ValuesTypeStr    ValuesType = "str"
	ValuesTypeNumber ValuesType = "number"
)

type Values struct {
	Str    *string
	Number *float64

	Type ValuesType
}

func CreateValuesStr(str string) Values {
	typ := ValuesTypeStr

	return Values{
		Str:  &str,
		Type: typ,
	}
}

func CreateValuesNumber(number float64) Values {
	typ := ValuesTypeNumber

	return Values{
		Number: &number,
		Type:   typ,
	}
}

func (u *Values) UnmarshalJSON(data []byte) error {

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = ValuesTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = ValuesTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Values) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// RequestsPerSecondSchemaResult - A representation of a single metric to build a line in a graph
type RequestsPerSecondSchemaResult struct {
	// A key value set representing the metric
	Metric *Metric `json:"metric,omitempty"`
	// An array of arrays. Each element of the array is an array of size 2 consisting of the 2 axis for the graph: in position zero the x axis represented as a number and position one the y axis represented as string
	Values [][]Values `json:"values,omitempty"`
}

func (o *RequestsPerSecondSchemaResult) GetMetric() *Metric {
	if o == nil {
		return nil
	}
	return o.Metric
}

func (o *RequestsPerSecondSchemaResult) GetValues() [][]Values {
	if o == nil {
		return nil
	}
	return o.Values
}

// ResultType - Prometheus compatible result type.
type ResultType string

const (
	ResultTypeMatrix ResultType = "matrix"
	ResultTypeVector ResultType = "vector"
	ResultTypeScalar ResultType = "scalar"
	ResultTypeString ResultType = "string"
)

func (e ResultType) ToPointer() *ResultType {
	return &e
}

func (e *ResultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "matrix":
		fallthrough
	case "vector":
		fallthrough
	case "scalar":
		fallthrough
	case "string":
		*e = ResultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResultType: %v", v)
	}
}

// Data - The query result from prometheus
type Data struct {
	// An array of values per metric. Each one represents a line in the graph labeled by its metric name
	Result []RequestsPerSecondSchemaResult `json:"result,omitempty"`
	// Prometheus compatible result type.
	ResultType *ResultType `json:"resultType,omitempty"`
}

func (o *Data) GetResult() []RequestsPerSecondSchemaResult {
	if o == nil {
		return nil
	}
	return o.Result
}

func (o *Data) GetResultType() *ResultType {
	if o == nil {
		return nil
	}
	return o.ResultType
}

// Status - Whether the query against prometheus succeeded or failed
type Status string

const (
	StatusSuccess Status = "success"
	StatusFailure Status = "failure"
)

func (e Status) ToPointer() *Status {
	return &e
}

func (e *Status) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "failure":
		*e = Status(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Status: %v", v)
	}
}

// RequestsPerSecondSchema - Statistics for usage of Unleash, formatted so it can easily be used in a graph
type RequestsPerSecondSchema struct {
	// The query result from prometheus
	Data *Data `json:"data,omitempty"`
	// Whether the query against prometheus succeeded or failed
	Status *Status `json:"status,omitempty"`
}

func (o *RequestsPerSecondSchema) GetData() *Data {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *RequestsPerSecondSchema) GetStatus() *Status {
	if o == nil {
		return nil
	}
	return o.Status
}
