// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy/terraform-provider-terraform/internal/sdk/pkg/models/shared"
	"github.com/speakeasy/terraform-provider-terraform/internal/sdk/pkg/utils"
	"net/http"
)

type DownloadType string

const (
	DownloadTypeBoolean DownloadType = "boolean"
	DownloadTypeStr     DownloadType = "str"
	DownloadTypeNumber  DownloadType = "number"
)

type Download struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type DownloadType
}

func CreateDownloadBoolean(boolean bool) Download {
	typ := DownloadTypeBoolean

	return Download{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateDownloadStr(str string) Download {
	typ := DownloadTypeStr

	return Download{
		Str:  &str,
		Type: typ,
	}
}

func CreateDownloadNumber(number float64) Download {
	typ := DownloadTypeNumber

	return Download{
		Number: &number,
		Type:   typ,
	}
}

func (u *Download) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = DownloadTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = DownloadTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = DownloadTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Download) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EnvironmentsType string

const (
	EnvironmentsTypeBoolean EnvironmentsType = "boolean"
	EnvironmentsTypeStr     EnvironmentsType = "str"
	EnvironmentsTypeNumber  EnvironmentsType = "number"
)

type Environments struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type EnvironmentsType
}

func CreateEnvironmentsBoolean(boolean bool) Environments {
	typ := EnvironmentsTypeBoolean

	return Environments{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateEnvironmentsStr(str string) Environments {
	typ := EnvironmentsTypeStr

	return Environments{
		Str:  &str,
		Type: typ,
	}
}

func CreateEnvironmentsNumber(number float64) Environments {
	typ := EnvironmentsTypeNumber

	return Environments{
		Number: &number,
		Type:   typ,
	}
}

func (u *Environments) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = EnvironmentsTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = EnvironmentsTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = EnvironmentsTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Environments) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type FeatureTogglesType string

const (
	FeatureTogglesTypeBoolean FeatureTogglesType = "boolean"
	FeatureTogglesTypeStr     FeatureTogglesType = "str"
	FeatureTogglesTypeNumber  FeatureTogglesType = "number"
)

type FeatureToggles struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type FeatureTogglesType
}

func CreateFeatureTogglesBoolean(boolean bool) FeatureToggles {
	typ := FeatureTogglesTypeBoolean

	return FeatureToggles{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateFeatureTogglesStr(str string) FeatureToggles {
	typ := FeatureTogglesTypeStr

	return FeatureToggles{
		Str:  &str,
		Type: typ,
	}
}

func CreateFeatureTogglesNumber(number float64) FeatureToggles {
	typ := FeatureTogglesTypeNumber

	return FeatureToggles{
		Number: &number,
		Type:   typ,
	}
}

func (u *FeatureToggles) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = FeatureTogglesTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = FeatureTogglesTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = FeatureTogglesTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FeatureToggles) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// Format - Desired export format. Must be either `json` or `yaml`.
type Format string

const (
	FormatJSON Format = "json"
	FormatYaml Format = "yaml"
)

func (e Format) ToPointer() *Format {
	return &e
}

func (e *Format) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "yaml":
		*e = Format(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Format: %v", v)
	}
}

type ProjectsType string

const (
	ProjectsTypeBoolean ProjectsType = "boolean"
	ProjectsTypeStr     ProjectsType = "str"
	ProjectsTypeNumber  ProjectsType = "number"
)

type Projects struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type ProjectsType
}

func CreateProjectsBoolean(boolean bool) Projects {
	typ := ProjectsTypeBoolean

	return Projects{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateProjectsStr(str string) Projects {
	typ := ProjectsTypeStr

	return Projects{
		Str:  &str,
		Type: typ,
	}
}

func CreateProjectsNumber(number float64) Projects {
	typ := ProjectsTypeNumber

	return Projects{
		Number: &number,
		Type:   typ,
	}
}

func (u *Projects) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = ProjectsTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = ProjectsTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = ProjectsTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Projects) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type StrategiesType string

const (
	StrategiesTypeBoolean StrategiesType = "boolean"
	StrategiesTypeStr     StrategiesType = "str"
	StrategiesTypeNumber  StrategiesType = "number"
)

type Strategies struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type StrategiesType
}

func CreateStrategiesBoolean(boolean bool) Strategies {
	typ := StrategiesTypeBoolean

	return Strategies{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateStrategiesStr(str string) Strategies {
	typ := StrategiesTypeStr

	return Strategies{
		Str:  &str,
		Type: typ,
	}
}

func CreateStrategiesNumber(number float64) Strategies {
	typ := StrategiesTypeNumber

	return Strategies{
		Number: &number,
		Type:   typ,
	}
}

func (u *Strategies) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = StrategiesTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = StrategiesTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = StrategiesTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Strategies) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type TagsType string

const (
	TagsTypeBoolean TagsType = "boolean"
	TagsTypeStr     TagsType = "str"
	TagsTypeNumber  TagsType = "number"
)

type Tags struct {
	Boolean *bool
	Str     *string
	Number  *float64

	Type TagsType
}

func CreateTagsBoolean(boolean bool) Tags {
	typ := TagsTypeBoolean

	return Tags{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateTagsStr(str string) Tags {
	typ := TagsTypeStr

	return Tags{
		Str:  &str,
		Type: typ,
	}
}

func CreateTagsNumber(number float64) Tags {
	typ := TagsTypeNumber

	return Tags{
		Number: &number,
		Type:   typ,
	}
}

func (u *Tags) UnmarshalJSON(data []byte) error {

	boolean := new(bool)
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = boolean
		u.Type = TagsTypeBoolean
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = TagsTypeStr
		return nil
	}

	number := new(float64)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = number
		u.Type = TagsTypeNumber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Tags) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type ExportRequest struct {
	// Whether exported data should be downloaded as a file.
	Download *Download `queryParam:"style=form,explode=true,name=download"`
	// Whether environments should be included in the exported data.
	Environments *Environments `queryParam:"style=form,explode=true,name=environments"`
	// Whether feature toggles should be included in the exported data.
	FeatureToggles *FeatureToggles `queryParam:"style=form,explode=true,name=featureToggles"`
	// Desired export format. Must be either `json` or `yaml`.
	Format *Format `default:"json" queryParam:"style=form,explode=true,name=format"`
	// Whether projects should be included in the exported data.
	Projects *Projects `queryParam:"style=form,explode=true,name=projects"`
	// Whether strategies should be included in the exported data.
	Strategies *Strategies `queryParam:"style=form,explode=true,name=strategies"`
	// Whether tag types, tags, and feature_tags should be included in the exported data.
	Tags *Tags `queryParam:"style=form,explode=true,name=tags"`
}

func (e ExportRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExportRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ExportRequest) GetDownload() *Download {
	if o == nil {
		return nil
	}
	return o.Download
}

func (o *ExportRequest) GetEnvironments() *Environments {
	if o == nil {
		return nil
	}
	return o.Environments
}

func (o *ExportRequest) GetFeatureToggles() *FeatureToggles {
	if o == nil {
		return nil
	}
	return o.FeatureToggles
}

func (o *ExportRequest) GetFormat() *Format {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *ExportRequest) GetProjects() *Projects {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *ExportRequest) GetStrategies() *Strategies {
	if o == nil {
		return nil
	}
	return o.Strategies
}

func (o *ExportRequest) GetTags() *Tags {
	if o == nil {
		return nil
	}
	return o.Tags
}

type ExportResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// stateSchema
	StateSchema *shared.StateSchema
}

func (o *ExportResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *ExportResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *ExportResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *ExportResponse) GetStateSchema() *shared.StateSchema {
	if o == nil {
		return nil
	}
	return o.StateSchema
}
