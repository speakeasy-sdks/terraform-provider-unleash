// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"unleash/internal/sdk"
	"unleash/internal/sdk/pkg/models/operations"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &FeatureEnvironmentDataSource{}
var _ datasource.DataSourceWithConfigure = &FeatureEnvironmentDataSource{}

func NewFeatureEnvironmentDataSource() datasource.DataSource {
	return &FeatureEnvironmentDataSource{}
}

// FeatureEnvironmentDataSource is the data source implementation.
type FeatureEnvironmentDataSource struct {
	client *sdk.UnleashServerAPI
}

// FeatureEnvironmentDataSourceModel describes the data model.
type FeatureEnvironmentDataSourceModel struct {
	Enabled      types.Bool              `tfsdk:"enabled"`
	Environment  types.String            `tfsdk:"environment"`
	FeatureName  types.String            `tfsdk:"feature_name"`
	Name         types.String            `tfsdk:"name"`
	ProjectID    types.String            `tfsdk:"project_id"`
	SortOrder    types.Number            `tfsdk:"sort_order"`
	Strategies   []FeatureStrategySchema `tfsdk:"strategies"`
	Type         types.String            `tfsdk:"type"`
	VariantCount types.Number            `tfsdk:"variant_count"`
	Variants     []VariantSchema         `tfsdk:"variants"`
}

// Metadata returns the data source type name.
func (r *FeatureEnvironmentDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_feature_environment"
}

// Schema defines the schema for the data source.
func (r *FeatureEnvironmentDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "FeatureEnvironment DataSource",

		Attributes: map[string]schema.Attribute{
			"enabled": schema.BoolAttribute{
				Computed:    true,
				Description: `` + "`" + `true` + "`" + ` if the feature is enabled for the environment, otherwise ` + "`" + `false` + "`" + `.`,
			},
			"environment": schema.StringAttribute{
				Optional:    true,
				Description: `The name of the environment`,
			},
			"feature_name": schema.StringAttribute{
				Optional:    true,
				Description: `The name of the feature`,
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Description: `The name of the environment`,
			},
			"project_id": schema.StringAttribute{
				Required: true,
			},
			"sort_order": schema.NumberAttribute{
				Computed:    true,
				Description: `The sort order of the feature environment in the feature environments list`,
			},
			"strategies": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"constraints": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"case_insensitive": schema.BoolAttribute{
										Computed:    true,
										Description: `Whether the operator should be case sensitive or not. Defaults to ` + "`" + `false` + "`" + ` (being case sensitive).`,
									},
									"context_name": schema.StringAttribute{
										Computed:    true,
										Description: `The name of the context field that this constraint should apply to.`,
									},
									"inverted": schema.BoolAttribute{
										Computed:    true,
										Description: `Whether the result should be negated or not. If ` + "`" + `true` + "`" + `, will turn a ` + "`" + `true` + "`" + ` result into a ` + "`" + `false` + "`" + ` result and vice versa.`,
									},
									"operator": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"NOT_IN",
												"IN",
												"STR_ENDS_WITH",
												"STR_STARTS_WITH",
												"STR_CONTAINS",
												"NUM_EQ",
												"NUM_GT",
												"NUM_GTE",
												"NUM_LT",
												"NUM_LTE",
												"DATE_AFTER",
												"DATE_BEFORE",
												"SEMVER_EQ",
												"SEMVER_GT",
												"SEMVER_LT",
											),
										},
										MarkdownDescription: `must be one of [NOT_IN, IN, STR_ENDS_WITH, STR_STARTS_WITH, STR_CONTAINS, NUM_EQ, NUM_GT, NUM_GTE, NUM_LT, NUM_LTE, DATE_AFTER, DATE_BEFORE, SEMVER_EQ, SEMVER_GT, SEMVER_LT]` + "\n" +
											`The operator to use when evaluating this constraint. For more information about the various operators, refer to [the strategy constraint operator documentation](https://docs.getunleash.io/reference/strategy-constraints#strategy-constraint-operators).`,
									},
									"value": schema.StringAttribute{
										Computed:    true,
										Description: `The context value that should be used for constraint evaluation. Use this property instead of ` + "`" + `values` + "`" + ` for properties that only accept single values.`,
									},
									"values": schema.ListAttribute{
										Computed:    true,
										ElementType: types.StringType,
										Description: `The context values that should be used for constraint evaluation. Use this property instead of ` + "`" + `value` + "`" + ` for properties that accept multiple values.`,
									},
								},
							},
							Description: `A list of the constraints attached to the strategy. See https://docs.getunleash.io/reference/strategy-constraints`,
						},
						"disabled": schema.BoolAttribute{
							Computed:    true,
							Description: `A toggle to disable the strategy. defaults to false. Disabled strategies are not evaluated or returned to the SDKs`,
						},
						"feature_name": schema.StringAttribute{
							Computed:    true,
							Description: `The name or feature the strategy is attached to`,
						},
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `A uuid for the feature strategy`,
						},
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The name or type of strategy`,
						},
						"parameters": schema.MapAttribute{
							Computed:    true,
							ElementType: types.StringType,
							Description: `A list of parameters for a strategy`,
						},
						"segments": schema.ListAttribute{
							Computed:    true,
							ElementType: types.NumberType,
							Description: `A list of segment ids attached to the strategy`,
						},
						"sort_order": schema.NumberAttribute{
							Computed:    true,
							Description: `The order of the strategy in the list`,
						},
						"title": schema.StringAttribute{
							Computed:    true,
							Description: `A descriptive title for the strategy`,
						},
						"variants": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Computed:    true,
										Description: `The variant name. Must be unique for this feature toggle`,
									},
									"payload": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"json",
														"csv",
														"string",
													),
												},
												MarkdownDescription: `must be one of [json, csv, string]` + "\n" +
													`The type of the value. Commonly used types are string, json and csv.`,
											},
											"value": schema.StringAttribute{
												Computed:    true,
												Description: `The actual value of payload`,
											},
										},
										Description: `Extra data configured for this variant`,
									},
									"stickiness": schema.StringAttribute{
										Computed:    true,
										Description: `The [stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) to use for distribution of this variant. Stickiness is how Unleash guarantees that the same user gets the same variant every time`,
									},
									"weight": schema.Int64Attribute{
										Computed:    true,
										Description: `The weight is the likelihood of any one user getting this variant. It is an integer between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information`,
									},
									"weight_type": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"variable",
												"fix",
											),
										},
										MarkdownDescription: `must be one of [variable, fix]` + "\n" +
											`Set to ` + "`" + `fix` + "`" + ` if this variant must have exactly the weight allocated to it. If the type is ` + "`" + `variable` + "`" + `, the weight will adjust so that the total weight of all variants adds up to 1000. Refer to the [variant weight documentation](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight).`,
									},
								},
							},
							Description: `Strategy level variants`,
						},
					},
				},
				Description: `A list of activation strategies for the feature environment`,
			},
			"type": schema.StringAttribute{
				Computed:    true,
				Description: `The type of the environment`,
			},
			"variant_count": schema.NumberAttribute{
				Computed:    true,
				Description: `The number of defined variants`,
			},
			"variants": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Computed:    true,
							Description: `The variants name. Is unique for this feature toggle`,
						},
						"overrides": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"context_name": schema.StringAttribute{
										Computed:    true,
										Description: `The name of the context field used to determine overrides`,
									},
									"values": schema.ListAttribute{
										Computed:    true,
										ElementType: types.StringType,
										Description: `Which values that should be overriden`,
									},
								},
							},
							Description: `Overrides assigning specific variants to specific users. The weighting system automatically assigns users to specific groups for you, but any overrides in this list will take precedence.`,
						},
						"payload": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"json",
											"csv",
											"string",
										),
									},
									MarkdownDescription: `must be one of [json, csv, string]` + "\n" +
										`The type of the value. Commonly used types are string, json and csv.`,
								},
								"value": schema.StringAttribute{
									Computed:    true,
									Description: `The actual value of payload`,
								},
							},
							Description: `Extra data configured for this variant`,
						},
						"stickiness": schema.StringAttribute{
							Computed:    true,
							Description: `[Stickiness](https://docs.getunleash.io/reference/feature-toggle-variants#variant-stickiness) is how Unleash guarantees that the same user gets the same variant every time`,
						},
						"weight": schema.NumberAttribute{
							Computed:    true,
							Description: `The weight is the likelihood of any one user getting this variant. It is a number between 0 and 1000. See the section on [variant weights](https://docs.getunleash.io/reference/feature-toggle-variants#variant-weight) for more information`,
						},
						"weight_type": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"variable",
									"fix",
								),
							},
							MarkdownDescription: `must be one of [variable, fix]` + "\n" +
								`Set to fix if this variant must have exactly the weight allocated to it. If the type is variable, the weight will adjust so that the total weight of all variants adds up to 1000`,
						},
					},
				},
				Description: `A list of variants for the feature environment`,
			},
		},
	}
}

func (r *FeatureEnvironmentDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.UnleashServerAPI)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.UnleashServerAPI, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *FeatureEnvironmentDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *FeatureEnvironmentDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	environment := data.Environment.ValueString()
	featureName := data.FeatureName.ValueString()
	projectID := data.ProjectID.ValueString()
	request := operations.GetFeatureEnvironmentRequest{
		Environment: environment,
		FeatureName: featureName,
		ProjectID:   projectID,
	}
	res, err := r.client.Features.GetFeatureEnvironment(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.FeatureEnvironmentSchema == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromGetResponse(res.FeatureEnvironmentSchema)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
